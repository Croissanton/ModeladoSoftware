model P2

class Clock
    attributes

        NOW: Integer init = 0
        resolution: Integer init = 1
        cont: Integer init = 0

    operations
        tick()
            begin
                self.NOW := self.NOW + self.resolution;
                for o in self.ao do
                    o.tick()
                end;
            end
        run(n:Integer)
            begin
                for i in Sequence{1..n} do
                    self.tick()
                end
            end
end

abstract class ActiveObject
    operations
        tick() begin end
end

class Tren < ActiveObject
    attributes
        cont: Integer init = 0
        direccionNormal : Boolean init: true
        averiado : Boolean init: false
    operations     
        move()
            begin
                self.cont:=0;
                delete(self, self.estacion) from Estaciona;
            end
            pre PuedeCircular: ((not self.averiado) and (self.segmento = null) and
                ((self.direccionNormal and not self.estacion.segmento->select(s | s.linea->includes(self.linea))->asSequence()->first().viaNormalOcupada) or
                (not self.direccionNormal and not self.estacion.segmento->select(s | s.linea->includes(self.linea))->asSequence()->last().viaContrariaOcupada)))
            pre minutoEstacionado: self.cont = 1
        stop()
            begin
                self.cont:=0;
                delete(self, self.segmento) from Circula;
            end
        seAveria()
            begin
                self.averiado:=true;
            end
        seRepara()
            begin
                self.averiado:=false;
                self.cont:=0;
            end
        avanzaEstacion()
            begin
                if (self.direccionNormal or self.linea.principio = self.estacion) then
                    insert(self, self.segmento.estacion->asSequence()->last()) into Estaciona;
                    self.direccionNormal := true;
                end;
                if (not self.direccionNormal or self.linea.final = self.estacion) then
                    insert(self, self.segmento.estacion->asSequence()->first()) into Estaciona;
                    self.direccionNormal := false;
                end;
                self.stop();
            end
            pre circulando: self.segmento <> null
            pre dosMinutos: self.cont = 2
        tick()
            begin
                if self.segmento <> null then 
                    self.cont:= self.cont + self.clock.resolution;
                end;
            end
  statemachines
    psm TrenMovimiento
      states
        s: initial 
        estacionado [self.segmento = null]
        circulando [self.segmento <> null]   
      transitions
        s -> estacionado {create}
        estacionado -> estacionado {tick()}
        estacionado -> circulando { [(not self.averiado) and ((self.direccionNormal and not self.estacion.segmento->select(s | s.linea->includes(self.linea))->asSequence()->first().viaNormalOcupada) or (not self.direccionNormal and not self.estacion.segmento->select(s | s.linea->includes(self.linea))->asSequence()->last().viaContrariaOcupada)) and self.cont = 1] move() }
        circulando -> circulando {tick()}
        circulando -> estacionado { [self.cont = 2] avanzaEstacion() }
    end
    psm TrenDisponibilidad
        states
        s: initial
        disponible [self.averiado = false]
        averiado [self.averiado = true]
        transitions
        s -> disponible {create}
        disponible -> averiado {seAveria()}
        averiado -> disponible {seRepara()}
    end
end

class Segmento
    attributes
        viaNormalOcupada :  Boolean init: false
        viaContrariaOcupada : Boolean init: false
end

class Estacion
    
end

class Linea
    
end



aggregation LineaSegmento between
    Linea [*] role linea
    Segmento [*] role segmento
end

aggregation SegmentoEstacion between
    Segmento [*] role segmento
    Estacion [2] role estacion
end

association Circula between
    Tren [0..2] role tren
    Segmento [0..1] role segmento
end

association Estaciona between
    Tren [*] role tren
    Estacion [0..1] role estacion
end

association PerteneceA between
    Tren [1..*] role tren
    Linea [1] role linea
end

association PrincipioDe between
    Estacion [1] role principio
    Linea [*] role lineaPrincipio
end

association FinalDe between
    Estacion [1] role final
    Linea [*] role lineaFinal
end

association Time between
    Clock [1] 
    ActiveObject [*] role ao ordered
end

constraints
    context Segmento inv LineasDistintas:
        self.estacion->asSequence()->at(1).segmento->intersection(self.estacion->asSequence()->at(2).segmento)->forAll(s1, s2 | s1 = s2 or s1.linea <> s2.linea)


--    context Tren inv PuedeCircular:
--        (not self.averiado) and (self.segmento = null) and
--        ((self.direccionNormal and not self.estacion.segmento->select(s | s.linea->includes(self.linea))->asSequence()->first().viaNormalOcupada) or
--        (not self.direccionNormal and not self.estacion.segmento->select(s | s.linea->includes(self.linea))->asSequence()->last().viaContrariaOcupada))

    context Tren inv DireccionValida:
        (not (self.linea.principio = self.estacion) or not self.direccionNormal) or 
        (not (self.linea.final = self.estacion) or self.direccionNormal) 
