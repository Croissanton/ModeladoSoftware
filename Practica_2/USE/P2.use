model P2

class Clock
    attributes

        NOW: Integer init = 0
        resolution: Integer init = 1

    operations
        tick()
            begin
                self.NOW := self.NOW + self.resolution;
                for o in self.ao do
                    o.tick()
                end;
            end
        
        run(n:Integer)
            begin
                for i in Sequence{1..n} do
                    self.tick()
                end
            end
end

abstract class ActiveObject
    operations
        tick() begin end
end

class Tren < ActiveObject
    attributes
        direccionNormal : Boolean init: true
        averiado : Boolean init: false
end

class Segmento
    attributes
        viaNormalOcupada :  Boolean init: false
        viaContrariaOcupada : Boolean init: false
end

class Estacion
    
end

class Linea
    
end

aggregation LineaSegmento between
    Linea [*] role linea
    Segmento [*] role segmento
end

aggregation SegmentoEstacion between
    Segmento [*] role segmento
    Estacion [2] role estacion
end

association Circula between
    Tren [0..2] role tren
    Segmento [0..1] role segmento
end

association Estaciona between
    Tren [*] role tren
    Estacion [0..1] role estacion
end

association PerteneceA between
    Tren [1..*] role tren
    Linea [1] role linea
end

association PrincipioDe between
    Estacion [1] role principio
    Linea [*] role lineaPrincipio
end

association FinalDe between
    Estacion [1] role final
    Linea [*] role lineaFinal
end

association Time between
    Clock [1] 
    ActiveObject [*] role ao ordered
end

constraints
    context Segmento inv LineasDistintas:
        self.estacion->asSequence()->at(1).segmento->intersection(self.estacion->asSequence()->at(2).segmento)->forAll(s1, s2 | s1 = s2 or s1.linea <> s2.linea)


    context Tren inv PuedeCircular:
        (not self.averiado) and (self.segmento = null) and
        
        ((self.direccionNormal and not self.estacion.segmento->select(s | s.linea->includes(self.linea))->asSequence()->first().viaNormalOcupada) or
        (not self.direccionNormal and not self.estacion.segmento->select(s | s.linea->includes(self.linea))->asSequence()->last().viaContrariaOcupada))

    context Tren inv DireccionValida:
        (not (self.linea.principio = self.estacion) or not self.direccionNormal) or 
        (not (self.linea.final = self.estacion) or self.direccionNormal) 
